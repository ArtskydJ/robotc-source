#pragma config(ProgramType, StandaloneWiFi)
#pragma config(Sensor, in1,    base_level_limit_sw, sensorNone)
#pragma config(Sensor, in2,    ct_line_sensor,      sensorLineFollower)
#pragma config(Sensor, in3,    rt_line_sensor,      sensorLineFollower)
#pragma config(Sensor, in4,    lt_line_sensor,      sensorLineFollower)
#pragma config(Sensor, in5,    stack_tube_level_limit_sw, sensorNone)
#pragma config(Sensor, in6,    back_bumper_sw,      sensorNone)
#pragma config(Sensor, in7,    kill_sw,             sensorNone)
#pragma config(Sensor, dgtl1,  rt_encoder_A,        sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  lt_encoder_A,        sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  lt_sonar,            sensorSONAR_inch)
#pragma config(Sensor, dgtl7,  inner_upper_limit_sw, sensorTouch)
#pragma config(Sensor, dgtl8,  inner_lower_limit_sw, sensorTouch)
#pragma config(Sensor, dgtl9,  outer_upper_limit_sw, sensorTouch)
#pragma config(Sensor, dgtl10, outer_lower_limit_sw, sensorTouch)
#pragma config(Sensor, dgtl11, rt_sonar,            sensorSONAR_inch)
#pragma config(Motor,  port1,           lt_outer_lift, tmotorNormal, openLoop)
#pragma config(Motor,  port2,           rt_drive,      tmotorNormal, openLoop)
#pragma config(Motor,  port3,           lt_drive,      tmotorNormal, openLoop)
#pragma config(Motor,  port5,           lt_inner_lift, tmotorNormal, openLoop)
#pragma config(Motor,  port6,           rt_inner_lift, tmotorNormal, openLoop)
#pragma config(Motor,  port8,           grip_servo, tmotorNormal, openLoop)
#pragma config(Motor,  port9,           base_align_servo, tmotorNormal, openLoop)
#pragma config(Motor,  port10,          rt_outer_lift, tmotorNormal, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Roundup Team 599 Mentor bobcat robot
//Contains both manual and autonomous modes
//Has logic for auto_debug_mode that allows control of autonomous mode with joystick.
//Scripting matches the Vamfun Living room low hang programming challenge demo.
//Software has not been used or verified in competition.
//TBD Determine changes necessary to make it compatible with competition template.
//Vamfun 8/14/2010
//Revised 8/15/2010
//Added capability to call scripts in manual mode.  This is major change.
//Vex joystick button 8right now used to enter auto_debug_mode and also disconnect any scripts
//Hold 8 right down for 2 sec to enter script mode, one touch to disconnect.
//Kill switch and button 8 both disconnect all scripts.
//Added a reset_script() function.
//Fixed line tracker: needed to start track on center line rather than any line sensor.

// Motor Ports
//1 right outer lift motor 2 wire
//2 right drive motor
//3 left  drive motor
//4
//5 right inner lift motor 2 wire with 29 controller   This ensures 4 amp limit for rt and lt inner lift
//6 left  inner lift motor 2 wire with 29 controller   This ensures 4 amp limit for rt and lt inner lift
//7 grip tube lock servo
//8 base_align tube grasp servo
//9
//10 left outer lift motor 2 wire
//
//Defines ******************************************************************************************

#define START_STEP_AUTONOMOUS (int)1 //you can start your script at something other than 1
#define START_STEP_STACK (int)100
#define START_STEP_LIFT_STACK (int)200
#define START_STEP_LIFT_BASE_DROP (int)300
#define START_STEP_LOW_HANG (int)15
#define END_STEP (int)-999 // this will signal no script in progress

//Switch state defines
#define CLOSED 1
#define OPEN 0
//#define UP 1
//#define DOWN 0
//gripper positions
#define HOLD 0
#define DROP 1
#define DROP1 2
//base align servo positions
#define ALIGN_IN 0
#define ALIGN_OUT 1
#define ALIGN_OTHER 2
//lift positions
#define LIFT_DOWN 0
#define LIFT_PICKUP 1
#define LIFT_BASE_DROP 2
#define LIFT_UP 3
#define LIFT_STACK 4
#define LIFT_OTHER 5

#define RT_COMP_BIAS 20 //motor compensation bias...used to eliminate deadzone caused by friction
#define LT_COMP_BIAS 20

#define LINE_DET_THRESHOLD 1200 // This is the average of on and off line sensor values

// These defines set the upper and lower deadzone limits on motor inputs... presently not used
// They keep the joystick slop from causing motors to run.  Typically the values are around 5 pwm units
#define LL1 (-0) //motor 1 dead zone lower limit
#define UL1 0   //motor 1 dead sone upper limit
#define LL2 (-0)
#define UL2 0
#define LL3 (-0)
#define UL3 0
#define LL4 (-0)
#define UL4 0
#define LL5 (-0)
#define UL5 0
#define LL10 (-0)//5
#define UL10 0



// function prototypes *********************************************************************************
void all_motors_off();
int limit_127(int cmd);
int dzcomp( int dzcomp_bias,int cmd);
int deadzone_with_loss(int lower_limit,int upper_limit, int var);
int deadzone_noloss(int lower_limit, int upper_limit, int var);
void drive_function();
void lift_function();
void grip_function();
void base_align_function();
void heading_hold_function(int psi_deg_ref);
bool get_line_function(int port_no);
void track_line_function();
void reset_scripting_modes();
void reset_timers();
void reset_grip();
void autonomous_control();
void operator_control();
void auto_debug_function();
void autonomous_script();

// autonomous logic prototypes
int move_encoder(int goal , int fwd_speed );
int turn_encoder(int goal , int turn_rate );
int ms_timer_T1(int goal);
int set_lift(int goal, int pwm_input ); //goals: LIFT_DOWN,LIFT_PICKUP,LIFT_BASE_DROP,LIFT_UP
int set_lift_manual(int pwm_inner,int pwm_outer, int ms_wait);//timed individual lifts , no limit switches
int set_grip(int goal, int ms_wait) ; //goals: HOLD,DROP,DROP1

//Global variable definitions *********************************************************************************
// autonomous mode script control variables
bool binit_auto_timer = true;
bool bauto_debug_mode = false;
bool bstep = false;
bool bsingle_step_mode = false;
bool bstarted_script = false;
bool bfirst_pass = true ;
bool bauto_move = false;
bool bauto_turn = false;
bool bauto_lift = false;
bool bauto_grip = false;
bool sys_reset = true; //default = true
int step = END_STEP;// set initial script step at END_STEP which disables script engine until called
int done = 0; //default = 0

// Joystick Axes - Joystick 1
int RT_Ch1 = 0;
int RT_Ch2 = 0;
int RT_Ch3 = 0;
int RT_Ch4 = 0;

// Shoulder Buttons - Joystick 1
int RT_5Down = 0;
int RT_5Up = 0;
int RT_6Down = 0;
int RT_6Up = 0;

// Front Buttons - Joystick 1
int RT_7Up = 0;
int RT_7Right = 0;
int RT_7Down = 0;
int RT_7Left = 0;
int RT_8Up = 0;
int RT_8Right = 0;
int RT_8Down = 0;
int RT_8Left = 0;
//motor contol variables
int pwm_lt = 0 ;
int pwm_rt = 0 ;
int pwm_sym = 0 ;
int pwm_turn = 0;
int pwm_lift = 0;
int pwm_inner_lift = 0;
int pwm_outer_lift = 0;
int pwm_turn_hh  = 0;
int pwm_turn_line_track = 0;
//sensor variables;
float in_per_tick = 2.75*3.1416/360/2; // 2.75 is diameter of wheels, 360 is encoder ticks per rev
float deg_per_tick = 57.3*(2*in_per_tick)/15.5;  // 15.5 is dist between drive wheels
long dist_10in = 0;
long dist_10in_last = 0;
float rate = 0;
int  psi_deg = 0;
int  lt_sonar_inches = 0;
int  rt_sonar_inches = 0;
bool blt_line = false;
bool bct_line = false;
bool brt_line = false;
//Plunger variables
bool bHold = true;
bool bDrop = false;
bool bDrop1 = false;
bool bDrop_done = true;
int grip_cmd = HOLD;
int grip_state = HOLD;
int last_grip_state = HOLD;
int drop1_cmd = 0;
//base_align variables
bool bAbove_base = false;
bool bAlign_retracted = true;
int base_align_cmd= ALIGN_IN;
int state_base_align = ALIGN_IN;
bool bAbove_base_sw = OPEN ;
bool blast_Above_base_sw = OPEN ;
// lift variables
int lift_state = LIFT_DOWN;
bool blifts_manual = false; //this is set by button 8 Left
bool bstack = false;

// heading hold variables
int psi_error = 0;
int heading_ref = psi_deg;
bool bheading_hold_on = true;
// line track function variables
bool bauto_line_enable =false;
bool bback_bumper = false;


task main()
{

  bIfiAutonomousMode = false ;
  //bIfiAutonomousMode = true ;
  if(bIfiAutonomousMode) wait10Msec(200); //short delay to get out of the way

  //initialize sensors
  SensorValue(lt_encoder_A) = 0;
  SensorValue(rt_encoder_A) = 0;

  //initialize timers
  reset_timers();



  while(true)
  {

    //kill switch function : stops all autonomous activity and resets to manual control

    if(SensorValue(kill_sw) < 127 || RT_8Right) //using analog port since out of discretes
    {
      reset_scripting_modes();
      bIfiAutonomousMode = false; // now cortex must be recycled if trying to run AutonomousMode
    }

    //Read Joystick inputs ****************************************************************************
    // Joystick Axes - Joystick 1
    RT_Ch1 =    vexRT[Ch1];  // Returns -127 to +127
    RT_Ch2 =    vexRT[Ch2] ; // Returns -127 to +127
    RT_Ch3 =    vexRT[Ch3];  // Returns -127 to +127
    RT_Ch4 =    vexRT[Ch4] ; // Returns -127 to +127

    // Top Buttons - Joystick 1
    RT_5Down =  vexRT[Btn5D]; // Returns 1 or 0
    RT_5Up =    vexRT[Btn5U]; // Returns 1 or 0
    RT_6Down =  vexRT[Btn6D]; // Returns 1 or 0
    RT_6Up =    vexRT[Btn6U]; // Returns 1 or 0

    // Front Buttons - Joystick 1
    RT_7Up =    vexRT[Btn7U]; // Returns 1 or 0
    RT_7Right = vexRT[Btn7R]; // Returns 1 or 0
    RT_7Down =  vexRT[Btn7D]; // Returns 1 or 0
    RT_7Left =  vexRT[Btn7L]; // Returns 1 or 0
    RT_8Up =    vexRT[Btn8U]; // Returns 1 or 0
    RT_8Right = vexRT[Btn8R]; // Returns 1 or 0
    RT_8Down =  vexRT[Btn8D]; // Returns 1 or 0
    RT_8Left =  vexRT[Btn8L]; // Returns 1 or 0

    //Read and Process sensor data***************************************************************************

    //average encoder distance in tenths of an inch
    dist_10in = 10.*((float)SensorValue(lt_encoder_A)+ (float)SensorValue(rt_encoder_A))*in_per_tick;
    //encoder heading in degrees
    psi_deg   = (float)(SensorValue(lt_encoder_A)- SensorValue(rt_encoder_A))*deg_per_tick;

    //Derive an average rate from encoders to check top speed
    //time = time1[T4];
    if(dist_10in-dist_10in_last > 60 || dist_10in-dist_10in_last <-60|| time1[T4]> 1000)  //average the rate over 6 inches or 1 sec
    {
      rate = 100.*(float)(dist_10in-dist_10in_last)/(float)time1[T4] ;
      time1[T4]=0 ;

      dist_10in_last=dist_10in;
    }


    //back bumper switch (in a/d)
    bback_bumper = SensorValue(back_bumper_sw)<127;

    // Debounce limit switch for 1msec
    bAbove_base_sw =( SensorValue[base_level_limit_sw]<127) ; //Analog sensor port used... open = 254, closed 4
    wait1Msec(1);
    if(bAbove_base_sw != (SensorValue[base_level_limit_sw]<127) ) bAbove_base_sw = blast_Above_base_sw;
    bstack = SensorValue[stack_tube_level_limit_sw]<127;

    lt_sonar_inches = SensorValue[lt_sonar] ;
    rt_sonar_inches = SensorValue[rt_sonar] ;

    //Read Line Sensors and convert to bool.  true = online
    blt_line = get_line_function(lt_line_sensor);
    bct_line = get_line_function(ct_line_sensor);
    brt_line = get_line_function(rt_line_sensor);

    //Begin core function calls *************************************************************************************

    //generate commands for the action functions



    if(!bIfiAutonomousMode) auto_debug_function(); //call auto_debug_function if not in Autonomous mode

    if(bIfiAutonomousMode  || bauto_debug_mode)
    {
      if(step == END_STEP) step = START_STEP_AUTONOMOUS ; //get commands from scripting functions
    }
    else
    {
      operator_control();  // otherwise get commands from processed joystick inputs
    }

    autonomous_control(); //get commands from scripting functions both manual and autonomous


    track_line_function(); //call the line tracker ...but only active if bauto_line_enable = true

    if(bheading_hold_on && (pwm_turn!=0 || pwm_turn_line_track!=0)) // If turning then reset heading ref at current heading
    {
      heading_ref = psi_deg ;
    }

    heading_hold_function(heading_ref); //outputs pwm_turn_hh command


    //now use the action commands generated above

    drive_function(); //process pwm_sym and pwm_turn commands for motors
    lift_function(); //process pwm_lift and limit_switches for lift motors
    grip_function();//process grip_cmd for griper servo
    base_align_function();//process base_align_cmd for align servo




  }//end while



} // end task main

//begin function definitions ******************************************************************************************

void all_motors_off()
{
  int i=0;
  while(i<10)
  {
    motor[i]=0;
    i++;
  }


}
void reset_scripting_modes()
{
  step = END_STEP;
  bauto_move = false;
  bauto_turn = false;
  bauto_lift = false;
  bauto_grip= false;
  blifts_manual= false;// this can be set by script so must reset if disconnected mid way into script
  bauto_line_enable = false; // include because some scripting modes set this
  if(bstarted_script) bauto_debug_mode=false;


}

void reset_grip()
{
  bHold = false;
  bDrop = false;
  bDrop1 = false;
  bDrop_done = false;
  time1[T1]=0 ;
}

void reset_timers()

{
  ClearTimer(T1);
  ClearTimer(T2);
  ClearTimer(T3);
  ClearTimer(T4);

}

int limit_127(int cmd)
{
  if(cmd > 127 ) cmd = 127 ;

  if(cmd<-127  ) cmd = -127 ;
  return cmd ;
}
//dzcomp(..) is a dead zone compensation bias function.
//It adds a bias to the command input to compensate for motor coulumb friction losses
int dzcomp(int dzcomp_bias, int cmd)
{
  if(cmd>0) return cmd + dzcomp_bias;
  else if(cmd<0) return cmd - dzcomp_bias;
  else return 0;
}
// deadzone_noloss(..) returns input value when outside deadzone.
// Ie ... the output jumps to the input value when the input exceeds the deadzone limit
int deadzone_noloss(int lower_limit, int upper_limit, int var)
{

  if (var > upper_limit || var < lower_limit) return var;
  else return 0;

}
// deadzone_with_loss(..) returns the input value +_dz_limit when input exceeds deadzone
// Ie...as the command increases beyond the deadzond the output starts at zero at the deadzone edge
int deadzone_with_loss(int lower_limit, int upper_limit, int var)
{

  if (var > upper_limit) return var - upper_limit;
  else
    if( var < lower_limit) return var - lower_limit;
  else return 0;

}
//drive_function() computes the right and left motor commands from the symetric and turn pwm commands
void drive_function()
{

  pwm_rt = pwm_sym - pwm_turn -pwm_turn_hh - pwm_turn_line_track;
  pwm_lt = -pwm_sym -pwm_turn -pwm_turn_hh - pwm_turn_line_track;
  motor[rt_drive] =  -dzcomp( RT_COMP_BIAS, deadzone_with_loss(-RT_COMP_BIAS,RT_COMP_BIAS, pwm_rt)) ; // Right motor
  motor[lt_drive] =  -dzcomp( LT_COMP_BIAS, deadzone_with_loss(-LT_COMP_BIAS,LT_COMP_BIAS, pwm_lt)) ; // Left motor

}
//lift_function() processes the pwm_lift command.  It allocates the command to the inner lifts or outer lifts
//depending upon the limit switch states.
//It also computes the state of the lift for use by script functions.
void lift_function()
{

  //Compute lift states
  if(SensorValue(outer_lower_limit_sw) && SensorValue(inner_lower_limit_sw)) lift_state = LIFT_DOWN;
  else if(SensorValue(outer_lower_limit_sw) && bstack) lift_state = LIFT_STACK;
  else if(SensorValue(outer_lower_limit_sw) && SensorValue(inner_upper_limit_sw)) lift_state = LIFT_PICKUP;
  else if(SensorValue(outer_upper_limit_sw) && SensorValue(inner_upper_limit_sw)) lift_state = LIFT_UP;
  else if(SensorValue(inner_upper_limit_sw) && bAbove_base_sw) lift_state = LIFT_BASE_DROP;
  else lift_state = LIFT_OTHER;

  if(blifts_manual)
  { // control lifts directly independent of limit switches

    motor[rt_outer_lift] = pwm_outer_lift;  //hold outer lift motors
    motor[lt_outer_lift] = -pwm_outer_lift; //hold outer lift motors



    motor[rt_inner_lift] =  pwm_inner_lift ;
    motor[lt_inner_lift] =  -pwm_inner_lift;

  }
  else
  {  //use a single lift command and let the limit switches direct it to the proper motors


    //lift control
    if(SensorValue(inner_upper_limit_sw) == CLOSED)
    { // switch control input to outer lift if(SensorValue(outer_upper_limit_sw == CLOSED) pwm_lift = 0 ;

      motor[rt_inner_lift] =  15 ;
      motor[lt_inner_lift] =  -15 ;

      if(SensorValue(outer_upper_limit_sw) == CLOSED && pwm_lift > 0 ) pwm_lift = 0 ;
      else if(SensorValue(outer_lower_limit_sw)== CLOSED && pwm_lift < 0)

      {
        motor[rt_inner_lift] = deadzone_noloss(LL4,UL4, pwm_lift) ;
        motor[lt_inner_lift] = deadzone_noloss(LL5,UL5,-pwm_lift) ;
        motor[rt_outer_lift] = 10;  //hold outer lift motors
        motor[lt_outer_lift] = -10; //hold outer lift motors

      }
      motor[rt_outer_lift] =  10 + deadzone_noloss(LL1,UL1,  +pwm_lift);  //run right outer lift motors
      motor[lt_outer_lift] = -10 + deadzone_noloss(LL10,UL10,-pwm_lift); //run left outer lift motors
    }
    else
    { // switch control input to inner lift
      motor[rt_outer_lift] = 10;  //hold outer lift motors
      motor[lt_outer_lift] = -10; //hold outer lift motors


      if(SensorValue(inner_lower_limit_sw) == CLOSED && pwm_lift < 0) pwm_lift = 0;
      motor[rt_inner_lift] = 15 + deadzone_noloss(LL4,UL4,pwm_lift) ;
      motor[lt_inner_lift] = -15 + deadzone_noloss(LL5,UL5, -pwm_lift) ;
    }
  }
}
//base_align_function() sticks out a base align arm when the lifts are above a certain height
//this arm has a curved bar that sets the distance from the goal to properly drop tubes
//This allows the robot to hit a movable base without losing the tube drop alignment
void base_align_function()
{
  //Above base logic
  // This toggles the bAbove_base logic every time the base_level_limit_sw is depressed
  if( ((bAbove_base_sw &&pwm_lift>20) || SensorValue(outer_upper_limit_sw)) && !bAbove_base)
  {
    bAbove_base = true;

  }
  else
    if( (SensorValue(outer_lower_limit_sw)|| bAbove_base_sw &&(pwm_lift< -20)) && bAbove_base )
  {
    bAbove_base = false;

  }
  blast_Above_base_sw = bAbove_base_sw;


  //base_align Servo

  if(blifts_manual) base_align_cmd= ALIGN_IN; // keep it out of the way when manual
    if((base_align_cmd == ALIGN_IN || !bAbove_base || pwm_lift < -20 ) && !bAlign_retracted )
  {

    bAlign_retracted = true;

    state_base_align = ALIGN_IN;
  }
  else
    if((base_align_cmd == ALIGN_OUT || bAbove_base )&& bAlign_retracted)
  {
    bAlign_retracted = false;

    state_base_align = ALIGN_OUT;
  }


  motor[base_align_servo] = (bAlign_retracted && true)*127 + (!bAlign_retracted && true)*0 ;

}
//grip_function() controls the tube griper at the end of the grip
//It computs a grip_state and actuates the gripper servo
//States are: HOLD,DROP, DROP1
void grip_function()
{


  //Plunger Servo
  if(grip_cmd==HOLD && !bHold && bDrop_done) //RT_7Up
  {
    reset_grip();
    bHold = true;
    //grip_state = HOLD;
    motor[grip_servo] = 127 ; //set hold servo cmd

  }
  else
    if(grip_cmd==DROP  & !bDrop && bDrop_done)
  {
    reset_grip();
    bDrop = true;
    //grip_state = DROP;
    motor[grip_servo] = -25 ; //set drop servo cmd

  }
  else
    if(grip_cmd==DROP1 && !bDrop1 && bDrop_done)
  {
    reset_grip();
    bDrop1 = true;
    //grip_state = DROP1;
    drop1_cmd= (last_grip_state == HOLD)*40 + (last_grip_state == DROP)*60 ;
    motor[grip_servo] = drop1_cmd ;

  }
  if(!bDrop_done && time1[T1]> 250)  //give some time for the tubes to drop
  {
    bDrop_done = true;
    grip_state = grip_cmd;
  }

  last_grip_state = grip_state;
}


//heading_hold_function() holds heading relative to the input psi_deg_ref
//To hold existing heading ... call function with psi_deg_ref = psi_deg at time of call
void heading_hold_function(int psi_deg_ref)
{
  float k_hh = 5.  ;//pwm_cmd units per deg of heading error
  int hh_dead_band = 0;  // creats a +_ deadband

  if(bheading_hold_on)
  {
    psi_error = (psi_deg_ref - psi_deg);
    if(psi_error > hh_dead_band || psi_error < -hh_dead_band)
      pwm_turn_hh = k_hh*(float)psi_error;
    else
    {
      pwm_turn_hh = 0 ;
    }
  }

}

// get_line_function() outputs a discrete.... if on line output =1 else = 0
bool get_line_function(int port_no)
{

  bool white_line = true;// If the tape is white set true else false
  int threshold = LINE_DET_THRESHOLD;
  //printf("v %d l  %d \r",Get_Analog_Value(port_no), (Get_Analog_Value(port_no)> threshold));

  if(white_line)

  return (SensorValue(port_no) < threshold);
  else return (SensorValue(port_no)> threshold);

}
//The track_line_function() generates a pwm_turn_line_track command
//It outputs zero until bauto_line_enagle = true
void track_line_function()
{  /*
  These are defined globally
  blt_line = get_line_function(lt_line_sensor);
  bct_line = get_line_function(ct_line_sensor);
  brt_line = get_line_function(rt_line_sensor);
  */

  int turn_factor =100 ; // turn_pwm command when moving toward line
  static bool bstart_track = false;

  if(bauto_line_enable==false)
  {
    //auto_line_status = NOTDONE;
    bstart_track = false;
    pwm_turn_line_track = 0;
  }
  else
  {
    //Note: left and right are defined here looking toward the rear (ie facing the robot front).
    //Test to see if we are in track yet
    if(!bstart_track && bct_line ) {bstart_track=true;}
    if(bstart_track)
    {
      //if any sensor on then modify command
      if (blt_line|| brt_line|| bct_line)
      {

        if(bct_line)  pwm_turn_line_track = 0;  // On line so go straight

        else

        if (brt_line) pwm_turn_line_track = turn_factor ;// Right of Line, turn right since going backward now

        else

        if (blt_line) pwm_turn_line_track =  -turn_factor ;//Left of Line, turn left




      }

    }  //not in track so go straight

    else
    {
      //pwm_turn = 0;
    }


  }
}

//operater_control() uses the Vex Joystick inputs to create commands for the core functions
//Outputs: pwm_sym,pwm_turn,pwm_lift,grip_cmd,base_align_cmd and bauto_line_enable
//If blifts_manual=true, then pwm_inner_lift and pwm_outer_lift are generated
//Operator scripts are also commanded using buttons 5u,5d,6u and 6d
void operator_control()
{

  static bool blast_RT_7Left = false;
  static bool blast_RT_8Left = false;


  // set forward speed
  if(!bauto_move)
  {
    pwm_sym = deadzone_with_loss(-30,30,RT_Ch2);
  }
  // set turn rate
  if(!bauto_turn)
  {
    float pwm_turn_temp = (float)deadzone_with_loss(-20,20,RT_Ch1)/127.;
    //square turn to reduce sensitivity
    if(pwm_turn_temp<0) pwm_turn = -(pwm_turn_temp*pwm_turn_temp)*127.;
    else pwm_turn = pwm_turn_temp*pwm_turn_temp*127.;
  }
  //A push of button 8 left will set the lifts_manual mode
  //left x joy stick controls the outer lifts, left y joysticks control the inner lifts
  if(!bauto_lift)
  {
    if(RT_8Left&&!blast_RT_8Left && !blifts_manual )
    {
      blifts_manual=true;
    }
    else if(RT_8Left&&!blast_RT_8Left && blifts_manual)
    {
      blifts_manual=false;
    }

    blast_RT_8Left = RT_8Left>0 ;

    if(blifts_manual)
    {
      pwm_inner_lift = RT_Ch3;
      pwm_outer_lift = RT_Ch4;
    }
    else
    {
      pwm_lift = deadzone_noloss(-20,20,RT_Ch3);
    }
  }
  //Generate grip and base_align commands
  if(!bauto_grip)
  {
    if(RT_7Up) grip_cmd = HOLD;
    else
      if(RT_7Down) grip_cmd = DROP;
    else
      if(RT_7Right) grip_cmd = DROP1;
  }
  if(RT_8Down) base_align_cmd = ALIGN_IN;
  else
    if(RT_8Up) base_align_cmd = ALIGN_OUT;
  else base_align_cmd = ALIGN_OTHER;

  //Control auto_line function
  if(RT_7Left&&!blast_RT_7Left && !bauto_line_enable ) bauto_line_enable=true;
  else if(RT_7Left&&!blast_RT_7Left && bauto_line_enable) bauto_line_enable=false;
  blast_RT_7Left = RT_7Left>0;

  //Control auto_lift functions in operator mode
  if(!bauto_debug_mode)  // buttons 5 and 6 are used in auto debug so only use them here for operator scripting
    // if not in auto_debug_mode
  {
    if((RT_Ch3 < 10 || RT_Ch3 > -10) && !blifts_manual )
    {
      if(RT_5Down && step == END_STEP) step = START_STEP_STACK;

      if(RT_5Up && lift_state == LIFT_DOWN && step == END_STEP)  step = START_STEP_LIFT_STACK;

      if(RT_6Down && step == END_STEP) step = START_STEP_LIFT_BASE_DROP;

      if(RT_6Up && (lift_state != LIFT_UP || lift_state != LIFT_BASE_DROP )
      && step == END_STEP)  step = START_STEP_LOW_HANG;

    }
    else if(bauto_lift) step = END_STEP ;// disengage auto_lift if channel 3 of |joystick| > 10 or manual lifts




  }

}


//This function controls the script stepping
//When a script is finished done = 1 else done = 0.
//A system reset is performed when a script step first starts
void autonomous_control()
{
  static int last_step = END_STEP;
  if(last_step==END_STEP && step == END_STEP) sys_reset = true;
  if(step == END_STEP) return; //no script active so skip

  if(!bauto_debug_mode)
  {
    autonomous_script();

    if(done == 0)
    {
      sys_reset = false;
    }

    else
    {
      sys_reset = true;
      pwm_sym = pwm_turn = 0; // reset motor commands
      step++;  // auto step
      done = 0; // reset done flag
    }

  }
  else  //in auto_debug_mode so check for auto_debug discretes
    if(bstarted_script)
  {


    autonomous_script();

    if(done == 0)
    {
      sys_reset = false;
    }
    else
    {

      pwm_sym = pwm_turn = 0; // reset motor commands
      if(!bsingle_step_mode)
      {   sys_reset = true;
        step++;
        done = 0;
      }
      else
        if(bstep)
      { // if bstep is true enable the next step since we are in single_step mode
        bstep = false; // reset and wait for next push of button 5 down
        if(!bfirst_pass)
        {
          sys_reset = true;
          step ++;
          done = 0;

        }
        else bfirst_pass = false;

      }



    }
  }
}


//Autonomous logic functions
int move_encoder(int goal , int fwd_speed )
{

  static int target = 0;
  static int imdone = 0;

  if(sys_reset)
  {
    bauto_move = true;
    imdone = 0;
    target = dist_10in + goal;
    if (goal >=0) pwm_sym = fwd_speed ;
    else pwm_sym = -fwd_speed;
    return 0;
  }
  else
  {
    if (goal > 0  && (dist_10in < target) && imdone == 0) return 0;
    else if (goal < 0  && (dist_10in > target) && imdone == 0 ) return 0;
    else
    {
      bauto_move = false;
      imdone = 1;
      pwm_sym = 0 ; //stop motors
      return 1;

    }
  }
}
int turn_encoder(int goal , int turn_rate )
{

  static int target = 0;
  static int imdone = 0;

  if(sys_reset)
  {
    bauto_turn = true;
    imdone = 0;
    target = psi_deg + goal;
    if (goal >=0) pwm_turn = turn_rate ;
    else pwm_turn = -turn_rate;
    return 0;
  }
  else
  {
    if (goal > 0  && (psi_deg < target) && imdone == 0) return 0;
    else if (goal < 0  && (psi_deg > target) && imdone == 0 ) return 0;
    else
    {
      bauto_turn = false;
      imdone = 1;
      pwm_turn = 0 ; //stop motors
      return 1;

    }
  }
}
int ms_timer_T1(int goal )
{

  static int imdone = 0;
  if(sys_reset)
  {
    time1[T1] = 0; // reset timer
    imdone = 0;
    return 0;
  }
  else
  {
    if(time1[T1] < goal && !imdone) return 0;
    else
    {
      imdone = 1;
      return 1;
    }
  }
}
int set_lift(int goal, int pwm_input )
{
  static int imdone = 0;

  if(sys_reset)
  {
    bauto_lift = true;
    pwm_lift = pwm_input;
    imdone = 0;
    return 0;
  }
  else
  {

    if(lift_state != goal  && !imdone) return 0;
    else
    {
      bauto_lift = false;
      pwm_lift = 0;
      imdone = 1;
      return 1;
    }
  }
}

//set_grip(..) is a one step process if goal is HOLD or DROP.  If goal is DROP1 then it is a two step
//process.  First a single tube is dropped and then the remaining tubes are lowered to the end of the grip
//by activating a goal = HOLD.
//This function has an additional ms_wait after the drop is executed if desired.
int set_grip(int goal, int ms_wait)
{
  static int imdone = 0;
  static int goal_temp = 0;
  static bool bFirst_goal_done = false;

  if(sys_reset)
  {
    bauto_grip = true;
    grip_cmd=goal;
    bFirst_goal_done = false;
    goal_temp = goal;
    imdone = 0;
    return 0;
  }

  if( (grip_state != goal_temp ) && !imdone ) return 0;
  else
    if(goal == DROP1 && !bFirst_goal_done) // then ready tubes for another drop by activating a HOLD
  {
    goal_temp = HOLD;
    grip_cmd = HOLD;
    bFirst_goal_done = true;

  }
  else
  {
    wait1Msec(ms_wait);
    imdone = 1;
    bauto_grip = false;
    return 1;
  }
}
int set_lift_manual(int pwm_inner,int pwm_outer, int ms_wait)
{
  static int imdone = 0;
  if(sys_reset)
  {
    time1[T1] = 0; // reset timer
    imdone = 0;
    bauto_lift = true;
    blifts_manual=true;
    pwm_inner_lift = pwm_inner;
    pwm_outer_lift = pwm_outer;
    return 0;
  }
  else
  {
    if(time1[T1] < ms_wait && !imdone) return 0;
    else
    {
      imdone = 1;
      bauto_lift = false;
      blifts_manual=false;
      pwm_inner_lift = 0;
      pwm_outer_lift = 0;
      return 1;
    }
  }
}
//auto_debug_function is an extension of the operator function.  It processes the four front switchs (5Up,5Down,6Up,6Down)
//to allow a joystick button to initiate and terminate an autonomous script.  If terminated, the operator() function
//is called and manual operator commands are used as normal.  The robot can be maneuvered into its starting state and
//another autonomous run can be made.
//Modes:  All modes are latched
//Arm autonomous mode (bauto_debug_mode=true) : Push 5Up and 6Up simultaneously for 2 seconds and release
//Set single stepping (bsingle_step_mode = true); Push 6Down
//Set continuous stepping (bsingle_step_mode = false); Push 6Up
//Start a step (bstep = true) : Push 5Down
//    After the step is executed, bstep is reset
//If bsingle_step_mode = false, a Push 5Down will run a complete script.
//Script disconnect (bauto_debug_mode= false) : Push 5Up after autonomous has been armed for 5 sec.
//The 5 second delay allows the a double use of 5Up for both arming and disconnecting.
void auto_debug_function()
{
  static bool binit_debug_done = false;
  static bool b5sec_in_auto_debug_mode = false;
  if(!bauto_debug_mode && !binit_debug_done) // initialize logic
  {
    bstarted_script = false;
    bsingle_step_mode = false;
    bstep = false;
    b5sec_in_auto_debug_mode = false;
    bfirst_pass = true;
    done = 0;
    step =END_STEP;
    sys_reset=true;
    bauto_move=false;
    bauto_turn=false;
    bauto_lift=false;
    bauto_grip=false;
    reset_timers();
    binit_debug_done = true;
  }

  if (RT_8Right && !b5sec_in_auto_debug_mode )//button 8 right pushed for 2 sec ->auto_debug_mode
  {
    if(binit_auto_timer)
    {time100[T2] = 0;
      pwm_sym = 0;
      pwm_turn = 0;
      binit_auto_timer = false;

    }

    if( time100[T2]>20 )
    {
      bauto_debug_mode = true;
      binit_debug_done = false;

    }

  }
  else binit_auto_timer = true;

  if( time100[T2]>70 && !b5sec_in_auto_debug_mode && bauto_debug_mode)
  {
    b5sec_in_auto_debug_mode = true;
  }

  if(RT_6Up && bauto_debug_mode && bsingle_step_mode) bsingle_step_mode = false;
  if(RT_6Down && bauto_debug_mode && !bsingle_step_mode) bsingle_step_mode = true; // push 6down to set single step auto mode

  if(RT_5Down && bauto_debug_mode && !bstep) bstep = true;
  if(bstep && !bstarted_script) bstarted_script = true;
  if(RT_8Right && (bstarted_script || b5sec_in_auto_debug_mode))
  {
    bauto_debug_mode = false;

  }


}
void autonomous_script() {
  //************************************************************************************************************
  //********************* ADD YOUR SCRIPT CODE BELOW HERE ******************************************************

  //START PURE AUTONOMOUS SCRIPT****************************************************************************
  // Pickup 4, move to goal,drop 1 twice, then drop two, then back up while line tracking
  // When the A frame is hit, turn 180 degs, raise lift above the 6 in crossbar
  // Perform a tip over maneuver to lean against the A frame
  // Raise the lifts until the grabbers are above the A frame.
  // Lower the lift until the grabbers grab and then lift the bottom up above 6 in.


  if(step  == 1)
  {

    done =set_lift(LIFT_DOWN,-40);// reset lift


  }
  else
    if(step == 2)
  {
    done = set_lift(LIFT_PICKUP,70); // ready lift for pickup

  }
  else
    if(step  == 3)
  {
    done = move_encoder(100,60); //move 10 inches 60 pwm

  }
  else
    if(step  == 4)
  {
    done = set_grip(DROP, 200); //open grip 200 ms delay

  }
  else
    if(step  == 5)
  {
    done = set_lift(LIFT_DOWN,-40); // lower grip into tubes at pwm = -40

  }
  else
    if(step  == 6)
  {
    done = set_grip(HOLD,400); //grab tubes with 400 ms delay

  }
  else
    if(step  == 7)
  {
    done = set_lift(LIFT_BASE_DROP,90); //ready to drop

  }
  else
    if(step  == 8)
  {
    int temp1 = move_encoder(110,60); //move 11 inches 60 pwm
    int temp2 = ms_timer_T1(3500); //if we bump into base.... stop after 3.5 sec
    if(temp1>0 || temp2>0) done = 1; //either event will trigger next step

  }
  else
    if(step == 9)
  {
    done = set_grip(DROP1, 1000); //drop one tube, wait 1000 ms
  }
  else
    if(step == 10)
  {
    done = set_grip(DROP1, 1000); //drop one tube, wait 1000 ms
  }
  else
    if(step == 11)
  {
    //done = ms_timer_T1(1000) ; // wait 1000 ms
    done = 1 ; // This is how you skip a step


  }
  else
    if(step == 12)
  {
    done = set_grip(DROP, 1000); //drop remaining tubes, wait 1000 ms
  }
  else
    if(step  == 13)
  {
    done = move_encoder(-70,90); //move back 7 inches 90 pwm

  }
  else
    if(step == 14)
  {
    done = set_lift(LIFT_PICKUP,-50);// lower lift for easier travel
  }
  else
    // START MANUAL OR AUTOMATIC LOW HANG  **************************************************************************
  if(step  == 15)
  {
    bauto_line_enable=true;
    if(move_encoder(-600,90)==1 || bback_bumper) done = 1 ; //move back till bumper hit, 90 pwm
      if(done) bauto_line_enable = false;
  }
  else
    if(step == 16)
  {
    done = turn_encoder(188,80);//turn around to face A frame side of ladder
  }
  else

  if(step  == 17)
  {
    done = move_encoder(35,60);//ready for tilt maneuver

  }
  else
    if(step  == 18)
  {
    done = set_lift(LIFT_BASE_DROP,90); //raise lift to get over 6 in bar

  }
  else
    if(step == 19)
  {
    done = move_encoder(40,127);//start fwd thrust

  }
  else
    if(step == 20)
  {
    done = move_encoder(-45,127);//reverse suddenly to cause a forward tilt toward A frame

  }
  else
    if(step == 21)
  {
    done = ms_timer_T1(1000);// delay 1 sec to allow robot to settle on A frame

  }
  else
    if(step == 22)
  {

    done = set_lift(LIFT_UP,127); //raise lift to put grabbers above the A frame
  }
  else
    if(step == 23)
  {
    done = ms_timer_T1(500);// delay .5 sec

  }
  else
    if(step == 24)
  {
    done = set_lift_manual(-127, 0,1000);//lower inner lift for 1 sec

  }
  else
    if(step == 25)
  {
    done = set_lift_manual(-30, -127,2000);//hold inner lift  and lower outer lift for 2 sec

  }
  // END AUTONOMOUS SCRIPT

  // BEGIN STACK SCRIPT ***************************************************************************************
  else
    if(step == 100)
  {
    done = set_grip(DROP,0); // open grip to ready plunger for drop into tube
  }
  else
    if(step == 101)
  {
    done = set_lift(LIFT_DOWN,-70);// lower the lift
  }
  else
    if(step == 102)
  {
    done = set_grip(HOLD,0);//grab the tubes
  }
  else
    if(step == 103)
  {
    done = set_lift(LIFT_STACK,+70);//raise the lift to the LIFT_STACK height.
  }
  //END STACK SCRIPT

  // BEGIN RAISE LIFT TO STACK HEIGHT SCRIPT ***********************************************************************
  else
    if(step == 200)
  {
    int done1 = set_lift(LIFT_STACK,+70);
    int done2 = ms_timer_T1(2000);
    if(done1 == 1 || done2 == 1)
    {
      done = 1;
      bauto_lift = false;//release the lift
    }
  }
  //END RAISE LIFT TO STACK HEIGHT SCRIPT

  else
  // BEGIN RAISE LIFT TO DROP HEIGHT SCRIPT *********************************************************************
  if(step == 300)
  {
    done = set_lift(LIFT_BASE_DROP, 70);
  }

  //END RAISE LIFT TO DROP HEIGHT SCRIPT
  else
    if(step == 400)
  {
    //NEW TBD SCRIPT
  }
  else
  {
    bauto_debug_mode=false;
    step = END_STEP;
  }

  //*****************************BOTTOM OF SCRIPT *****************************************************************
}
