#pragma config(ProgramType, Competition)
#pragma config(Sensor, in7,    kill_sw,             sensorPotentiometer)
#pragma config(Sensor, in8,    auto_select,         sensorPotentiometer)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)


//Written by Chris S.
//vamfun@yahoo.com
//599 Robodox Engineering Mentor
//see blog for further details www.vamfun.wordpress.com
//see Competition_Scripting_Template.h for variable definition and how to use program

#include <Competition_Scripting_Template.h> //599 include

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
  // All activities that occur before the competition starts
  // Example: clearing encoders, setting servo positions, ...
  Initialize();
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{

  // .....................................................................................
  // Insert user code here.
  // .....................................................................................

  Autonomous599();
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
  // User control code here, inside the loop

  User599();
}




//599 funcitons
void Autonomous599()
{
  while(true)
  {

    if((SensorValue[kill_sw] < 127)&& ENABLE_KILL_SWITCH) //kill button on robot is A/D port to save digital ports
    {

      if(script != no_script) // stop scripts by reinitializing
      {
        Initialize();
        bsingle_step_mode = false;
      }

      allMotorsOff();
      break;
    }
    Process_sensors(); // read and process sensors to get variables needed for functions

    Operator(); // read driver commands from joystick which are not under script control

    Select_autonomous_script();//call autonomous script based upon cortex input auto_select (in8) port status

    Run_scripts();// Runs the selected script from Select_autonomous_script() to get commnads from scripts

    //call core functions here that use commands from operator() and run_scripts() functions

    Core_functions();



  }//end while
}
void User599()
{
  while(true)
  {

    //Script disconnect and kill switch (DO NOT MODIFY except for reset_simulation)
    if(bdisconnect || (SensorValue[kill_sw] < 127)&& ENABLE_KILL_SWITCH) //kill button on robot is A/D port to save digital ports
    {

      if(script != no_script)
      {bauto_debug_mode = false;  // only reset this if a script is running since Btn8R
        // is also used for getting into auto_debug_mode and would reset the mode immediately

        Reset_timers();//put the timer resets in here since the timers are used to set auto_debug_mode

      }
      bdisconnect = false;
      bsingle_step_mode = false;
      bsingle_step = false;
      Reset_scripts();
      Reset_simulation();//remove when not using simulation
    }

    Process_sensors(); // read and process sensors to get variables needed for functions

    Operator(); // read driver commands from joystick which are not under script control

    Select_user_script();//read joystick buttons dedicated to intiating scripts

    Run_scripts();// get commnads from scripts named by Select_user_script();

    //call core functions here that use commands from Operator() and Run_scripts() functions
    //typically these would be Drive(),Lift(),Grip() etc.

    Core_functions();//



  }//end while

}

void Initialize()
{
  Reset_simulation();//delete later
  //Don't Modify these
  Reset_timers();
  Reset_scripts();
  bauto_debug_mode = false;
  bsingle_step_mode = false;
  bsingle_step = false;

  //Modify to match desired script calling order
  //select starting autonomous script number by reading A/D input auto_select port
  //use potentiometer or another port if more than two scripts are needed.  Below assumes a single plug.
  if(SensorValue[auto_select] > 127 )
  {
    auto_script_no = 2 ;  //if plug is out
  }
  else
  {
    auto_script_no = 1;  //if plug is in
  }

}

void Reset_timers()
{
  ClearTimer(T1);
  ClearTimer(T2);
  ClearTimer(T3);
  ClearTimer(T4);

}
void Reset_scripts()
{
  //Dont Modify these
  bsys_reset = true;
  script = no_script;
  auto_script_no=0;
  step = 0 ;

  //Modify these to match your script utility function flags to inhibit joystick axes
  auto_cmd1 = false;
  auto_cmd2 = false;
  auto_cmd3 = false;

}

void Reset_simulation() //delete later when not using sim
{

  total_time=0; //this is for simulation only
  time1[T2] = 0;//this is for simulation only
  dist1 = 0; //this is for simulation only
  dist2 = 0;//this is for simulation only
  dist3 = 0;//this is for simulation only
}

void Process_sensors()
{// read and process sensors... compute variables and logic needed by other functions
  //read gyro
  //read encoders
  //compute distances and angles
  //read manipulator positions
  //joystick inputs and assign to global variables
  //sonic sensors
  //line sensors
  //limit switches
  //potentiometers

  // other sensor stuff here

}

void Operator()
{
  // here we assign Vexnet buttons and joystick axes inputs to core function motor/servo pwm commands
  // typically pwm_foward,pwm_turn,pwm_lift,servo cmds etc

  //Simulated pwm_cmds generated by Joystick channels
  if(!auto_cmd1)//only compute these joystick axes when the auto_cmd's are not being used by script
  {
    pwm_cmd1 = vexRT[Ch1];
    if(pwm_cmd1<40 && pwm_cmd1 > -40) pwm_cmd1 = 0; //put deadzone for slop
  }
  if(!auto_cmd2)
  {
    pwm_cmd2 = vexRT[Ch2];
    if(pwm_cmd2<40 && pwm_cmd2 > -40) pwm_cmd2 = 0;
  }
  if(!auto_cmd3)
  {
    pwm_cmd3 = vexRT[Ch3];
    if(pwm_cmd3<40 && pwm_cmd3 > -40) pwm_cmd3 = 0;
  }

}
void Select_autonomous_script()
{

  //Do not modify
  switch(auto_script_no) //auto_script_no is generated by plugs or potentiometer in A/D port 8
  {
  case 0:
    ; //no script stops autonomous and waits for user mode to start
    break;


    //Modify these to match your script names
  case 1:
    script = auto_name_1;
    break;

  case 2:
    script = auto_name_2;
    break;

  case 3:
    script = auto_name_3;
    break;

  default:
    script = auto_name_1;// use first script as default

  }
}

void Select_user_script()


{ //Allow other scripts to be called if not in autonomousmode

  static int Btn8L_start_time = 0;
  static int Btn8R_start_time = 0;
  int time_Btn8R_down = 0;

  bool bBtn8L ;
  bool bBtn8R ;
  static bool blast_Btn8L = false;
  static bool blast_Btn8R = false;

  if(bauto_debug_mode)

  {
    //read buttons to call autonomous scripts in USER CONTROL mode
    if(script == no_script)
    {
      //Modify to match your calling logic and script names
      if(vexRT[Btn5D]) script = auto_name_1;//moves relative distance 1 up by 500 and restors it
        if(vexRT[Btn5U]) script = auto_name_2;//moves relative distance 2 up by 500 and restors it
        if(vexRT[Btn6D]) script = auto_name_3;//moves relative distance 3 up by 500 and restors it
        if(vexRT[Btn6U]) script = auto_name_4;////script increments total time by 1000,2000 and 3000 ms increments

    }

  }
  else
  { //read buttons to call scripts in USER CONTROL mode

    if(script == no_script)
    {
      //Modify to match your calling logic and script names
      if(vexRT[Btn5D]) script = name_1;//moves relative distance 1 up by 500 and restors it
        if(vexRT[Btn5U]) script = name_2;//moves relative distance 2 up by 500 and restors it
        if(vexRT[Btn6D]) script = name_3;//moves relative distance 3 up by 500 and restors it
        if(vexRT[Btn6U]) script = name_4;//script increments total time by 1000,2000 and 3000 ms increments
        //....add more here
    }
  }

  //DO NOT MODIFY
  bBtn8R = vexRT[Btn8R]>0;

  if(!bBtn8R)
  {
    Btn8R_start_time = time100[T1];

  }
  time_Btn8R_down= time100[T1] - Btn8R_start_time;//compute how long button 8R is down

  if(blast_Btn8R && !bBtn8R && time_Btn8R_down < 30)
  {
    bdisconnect = true; //treat button 8R push as a disconnec if released in less than 3 seconds
  }


  if(ENABLE_AUTO_DEBUG )//set by define.  Allows single_step_mode and auto_debug_mode to be used
  {
    //Logic for setting single step mode  (3 second push of Btn8L establishes mode)
    bBtn8L = vexRT[Btn8L]>0;

    if(!bBtn8L)
    {
      Btn8L_start_time = time100[T1];

    }

    if(bBtn8L && time100[T1]> Btn8L_start_time + 30 && !bsingle_step_mode)
    {
      bsingle_step_mode = true; // set single_step_mode after 3 second push of Btn8L
    }

    if(bBtn8L && !blast_Btn8L && bsingle_step_mode) bsingle_step=true; // once in mode, initiate single step



    //Logic for setting auto_debug_mode (3 second push of Btn8R establishes mode)

    if(time_Btn8R_down > 30 && !bauto_debug_mode)
    {
      bauto_debug_mode = true; //set auto_debug_mode after 3 second push of button 8R

    }

  }
  else
  {
    bauto_debug_mode = false;
    bsingle_step_mode = false;
    bsingle_step = false;
  }
  blast_Btn8L = bBtn8L;
  blast_Btn8R = bBtn8R;

}


void Run_scripts()
{ //Do not modify
  static int last_script = no_script;
  if(last_script != script && script != no_script)
  {
    step=0;
    bsys_reset = true;
  }

  last_script = script;
  if(script == no_script) return;

  switch(script)
  {
    //Modify to match your script names and scripts
  case name_1:
    Script_name_1();
    break;

  case name_2:
    Script_name_2();
    break;

  case name_3:
    Script_name_3();
    break;

  case name_4:
    Script_name_4();
    break;

  case auto_name_1:
    Script_auto_name_1();
    break;

  case auto_name_2:
    Script_auto_name_2();
    break;

  case auto_name_3:
    Script_auto_name_3();
    break;

  case auto_name_4:
    Script_auto_name_4();
    break;

    //do not modify between here and end of function
  default:
    Reset_scripts();
    return;
  }

  if(done == 1 && script != no_script)
  {
    if(bsingle_step_mode)
    {
      if(bsingle_step)
      {
        step++;//increment to go to next step if button 8L is pushed
        bsingle_step = false;
        bsys_reset = true; //this is used to initialize each do_something script function
      }

    }
    else
    {
      step++;
      bsys_reset = true; //this is used to initialize each do_something script function
    }
  }
}

void Core_functions()
{
  //core_functions contain the motor and manipulator functions for the robot.
  //These respond to commands generated by joystick and script inputs.
  //operator() and run_scripts() typically generate pwm_foward,pwm_turn,pwm_lift,servo cmds etc
  //These pwm_cmds are then allocated to motors by the core functions which are
  //typically

  //Line_tracker(); //uses engage logic from joystick and creates a turn command to track line
  //Drive(); //uses pwm_forward,pwm_turn to run drive motors.
  //Lifts(); //uses pwm_lift ... also responsible for computing lift state
  //Gripper();//uses servo command ... also responsible for computing gripper state


  //Remove if not using simulation
  //Here we just simulate encoder distances as a function of pwm rates to motors
  //these distances will be used by the move_dist_(ch1,ch2 or ch3) functions.
  if(time1[T2]> 100)
  {
    dist1 = dist1 + pwm_cmd1/5;
    dist2 = dist2 + pwm_cmd2/5;
    dist3 = dist3 + pwm_cmd3/5;
    time1[T2] = 0;
  }




}

//Put script utility functions below here *************************************************************
//The following functions are just examples on how to do scripting utilities and scripts
//Typical utilities
//int Set_lift(int goal, int speed)
//int Set_grip(int goal)
//int Move_encoder(int goal,int speed)
//int Turn_encoder(int goal, int speed)

//utilities used in simulation example

int Event_timer(int goal)
{
  // event_timer is just a sample timer that waits for goal ms
  static bool b_imdone = false;
  if(bsys_reset)
  {
    time1[T1] = 0; //initialize stuff for output
    b_imdone = false; //internal flag used to latch output when done
    bsys_reset = false;//return sys_reset to false once it is used to initialize
    return 0;
  }
  else
  {
    if(time1[T1] < goal && !b_imdone) return 0; //return 0 until you meet goal
    else
    {
      b_imdone = true;
      total_time = total_time + goal ; //simulated event is to increment total_time by goal
      return 1; //always return 1 when done
    }

  }
}
int Move_dist_ch1(int goal , int pwm_input)
{
  // test routine similar to what might be used for encoders
  // goal is the incremental distance you want to go from where you are
  // goal is + or -  and pwm_input is a magnitude of the motor pwm command (ie pwm_input >0)
  static int goal_abs1 = 0;
  static bool b_imdone1 = false;
  if(bsys_reset)
  {
    //initialize stuff for output
    auto_cmd1 = true; // take control of the motors that are used in this function
    goal_abs1 = dist1+goal; //compute goal in reference axis units.  Input goal is relative to where you are
    if(goal<0) pwm_cmd1 = -pwm_input; //move in direction of goal
    else pwm_cmd1 = pwm_input;
    b_imdone1 = false;
    bsys_reset = false;
    return 0;
  }
  else
  {
    if( (goal<0 && dist1 > goal_abs1 || goal>0 && dist1 < goal_abs1 )&& !b_imdone1) return 0;
    else
    {
      auto_cmd1 = false; //return control to joystick
      b_imdone1 = true;
      pwm_cmd1 = 0 ; //set the speed to zero again
      return 1;// sets done = 1
    }

  }
}
int Move_dist_ch2(int goal , int pwm_input)
{
  // test routine similar to what might be used for encoders
  // goal is the incremental distance you want to go from where you are
  // goal is + or -  and pwm_input is a magnitude of the motor pwm command (ie pwm_input >0)
  static int goal_abs2 = 0;
  static bool b_imdone2 = false;
  if(bsys_reset)
  {
    //initialize stuff for output
    auto_cmd2 = true; // take control of the motors that are used in this function
    goal_abs2 = dist2+goal; //compute goal in reference axis units.  Input goal is relative to where you are
    if(goal<0) pwm_cmd2 = -pwm_input; //move in direction of goal
    else pwm_cmd2 = pwm_input;
    b_imdone2 = false;
    bsys_reset = false;
    return 0;
  }
  else
  {
    if( (goal<0 && dist2 > goal_abs2 || goal>0 && dist2 < goal_abs2 )&& !b_imdone2) return 0;
    else
    {
      auto_cmd2 = false; //return control to joystick
      b_imdone2 = true;
      pwm_cmd2 = 0 ; //set the speed to zero again
      return 1;// sets done = 1
    }

  }
}
int Move_dist_ch3(int goal , int pwm_input)
{
  // test routine similar to what might be used for encoders
  // goal is the incremental distance you want to go from where you are
  // goal is + or -  and pwm_input is a magnitude of the motor pwm command (ie pwm_input >0)
  static int goal_abs3 = 0;
  static bool b_imdone3 = false;
  if(bsys_reset)
  {
    //initialize stuff for output
    auto_cmd3 = true; // take control of the motors that are used in this function
    goal_abs3 = dist3+goal; //compute goal in reference axis units.  Input goal is relative to where you are
    if(goal<0) pwm_cmd3 = -pwm_input; //move in direction of goal
    else pwm_cmd3 = pwm_input;
    b_imdone3 = false;
    bsys_reset = false;
    return 0;
  }
  else
  {
    if( (goal<0 && dist3 > goal_abs3 || goal>0 && dist3 < goal_abs3 )&& !b_imdone3) return 0;
    else
    {
      auto_cmd3 = false; //return control to joystick
      b_imdone3 = true;
      pwm_cmd3 = 0 ; //set the speed to zero again
      return 1;// sets done = 1
    }

  }
}



//Add scripts below here *************************************************************************************

void Script_name_1()
{
  switch(step)
  {
  case 0: //initialize script
    //your init code here
    done = 1;
    break;

  case 1:
    done= Move_dist_ch1(500, 50); //command a rate of pwm 100 amd move to dist1 = 500
    break;

  case 2:
    done= Move_dist_ch1(-500, 50);//command a rate of pwm 100 and move back -500 back to zero
    break;

  default:
    Reset_scripts();

  }

}
void Script_name_2()
{
  switch(step)
  {
  case 0: //initialize script
    //your init code here
    done = 1;
    break;

  case 1:
    done= Move_dist_ch2(500, 50); //command a rate of pwm 100 amd move to dist1 = 500
    break;

  case 2:
    done= Move_dist_ch2(-500, 50);//command a rate of pwm 100 and move back -500 back to zero
    break;

  default:
    Reset_scripts();

  }
}

void Script_name_3()
{
  switch(step)
  {
  case 0: //initialize script
    //your init code here
    done = 1;
    break;

  case 1:
    done= Move_dist_ch3(500, 50); //command a rate of pwm 100 amd move to dist1 = 500
    break;

  case 2:
    done= Move_dist_ch3(-500, 50);//command a rate of pwm 100 and move back -500 back to zero
    break;

  default:
    Reset_scripts();

  }
}
void Script_name_4()
{
  switch(step)
  {
  case 0: //initialize script
    //your init code here
    done = 1;
    break;

  case 1:
    done= Event_timer(1000);//causes a total_time to increment 1000 after 1 second then exits
    break;

  case 2:
    done= Event_timer(2000);//causes total_time to increment 2000 after 2 seconds then exits
    break;

  case 3:
    done= Event_timer(3000);//causes total_time to increment 3000 after 3 seconds then exits
    break;

  default:
    Reset_scripts();

  }
}

void Script_auto_name_1()
{
  switch(step)
  {
  case 0: //initialize script
    //your init code here
    done = 1;
    break;

  case 1:
    done= Move_dist_ch1(500, 50); //command a rate of pwm 100 amd move to dist1 = 500
    break;

  case 2:
    done= Move_dist_ch1(-500, 50);//command a rate of pwm 100 and move back -500 back to zero
    break;


  default:
    Reset_scripts();

  }

}
void Script_auto_name_2()
{
  switch(step)
  {
  case 0: //initialize script
    //your init code here
    done = 1;
    break;

  case 1:
    done= Move_dist_ch2(500, 50); //command a rate of pwm 100 amd move to dist1 = 500
    break;

  case 2:
    done= Move_dist_ch2(-500, 50);//command a rate of pwm 100 and move back -500 back to zero
    break;

  default:
    Reset_scripts();

  }

}
void Script_auto_name_3()
{
  switch(step)
  {
  case 0: //initialize script
    //your init code here
    done = 1;
    break;

  case 1:
    done= Move_dist_ch3(500, 50); //command a rate of pwm 100 amd move to dist1 = 500
    break;

  case 2:
    done= Move_dist_ch3(-500, 50);//command a rate of pwm 100 and move back -500 back to zero
    break;

  default:
    Reset_scripts();

  }

}

void Script_auto_name_4()
{
  switch(step)
  {
  case 0: //initialize script
    //your init code here
    done = 1;
    break;

  case 1:
    done= Event_timer(1000);//causes a total_time to increment 1000 after 1 second then exits
    break;

  case 2:
    done= Event_timer(2000);//causes total_time to increment 2000 after 2 seconds then exits
    break;

  case 3:
    done= Event_timer(3000);//causes total_time to increment 3000 after 3 seconds then exits
    break;

  default:
    Reset_scripts();
  }
}
