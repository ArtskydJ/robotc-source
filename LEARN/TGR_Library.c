#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    lfR,            sensorLineFollower)
#pragma config(Sensor, in2,    lfM,            sensorLineFollower)
#pragma config(Sensor, in3,    lfL,            sensorLineFollower)
#pragma config(Sensor, I2C_1,  leftArmEnc,     sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  leftWheelEnc,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  rightWheelEnc,  sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  rightArmEnc,    sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port2,           leftWheel,     tmotorVex393, openLoop, encoder, encoderPort, I2C_2, 1000)
#pragma config(Motor,  port3,           leftArm,       tmotorVex393, openLoop, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port6,           rightArm,      tmotorVex393, openLoop, encoder, encoderPort, I2C_4, 1000)
#pragma config(Motor,  port7,           claw,          tmotorVex269, openLoop)
#pragma config(Motor,  port8,           rightWheel,    tmotorVex393, openLoop, reversed, encoder, encoderPort, I2C_3, 1000)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*Two Guys and a Robot Official VEX Robotics Library*/

//Set constants for how many seconds it takes to move the arm up a degree, how many seconds it takes to turn one degree, how long an inch is in seconds, and how many degrees the arm needs to be lifted up.
const float degreeSecArm=0.02;
const float inchSec=0.083;
const float degreeSecFloor=0.036;
const float armLiftDegrees=90.0;
void armUp(float amount);
void armDown(float amount);
void forward(float inches);
void backward(float inches);
void LCDdisplay(string disp, int line);
void LCDdisplayn(short disp, int line);
void LCDinit();
void turnRight(int degrees);
void turnLeft(int degrees);
void clawOpen();
void clawClose();
bool getLCDButton(int button);

task armTile
{
  motor[leftArm]=-100;
  motor[rightArm]=-100;
  wait1Msec(1000);
  nMotorEncoder[rightArm]=0;
  nMotorEncoder[leftArm]=0;
  while(true)
  {
    if(nMotorEncoder[rightArm]<0)
{
  motor[rightArm]=60;
}
else if(nMotorEncoder[rightArm]>0)
{
  motor[rightArm]=0;
}
else
{
  motor[rightArm]=0;
}
if(nMotorEncoder[leftArm]<0)
{
  motor[leftArm]=60;
}
else
{
  motor[leftArm]=0;
}

}
}

task arm11
{
  LCDinit();
  nMotorEncoder[rightArm]=0;
  nMotorEncoder[leftArm]=0;
  while(true)
  {
    clearLCDLine(1);
    LCDdisplayn(nMotorEncoder[leftArm], 1);
    if(nMotorEncoder[rightArm]<700)
{
  motor[rightArm]=120;
}
else
{
  motor[rightArm]=10;
}
if(nMotorEncoder[leftArm]<700)
{
  motor[leftArm]=120;
}
else
{
  motor[leftArm]=10;
}

}
}

task arm20
{
  nMotorEncoder[rightArm]=0;
  nMotorEncoder[leftArm]=0;
  while(true)
  {
    if(nMotorEncoder[rightArm]<1000)
{
  motor[rightArm]=120;
}
else
{
  motor[rightArm]=10;
}
if(nMotorEncoder[leftArm]<1000)
{
  motor[leftArm]=120;
}
else
{
  motor[leftArm]=10;
}

}
}

void armDown(float amount)
{
  motor[leftArm]=-20;
  motor[rightArm]=-20;
  wait1Msec(degreeSecArm*amount*armLiftDegrees*1000);
  motor[leftArm]=0;
  motor[rightArm]=0;
}

void forward(float inches)
{
  motor[leftWheel]=127;
  motor[rightWheel]=127;
  wait1Msec(inchSec*inches*1000);
  motor[leftWheel]=0;
  motor[rightWheel]=0;
}

void backward(float inches)
{
  motor[leftWheel]=-127;
  motor[rightWheel]=-127;
  wait1Msec(inchSec*inches*1000);
  motor[leftWheel]=0;
  motor[rightWheel]=0;
}

void LCDinit()
{
  clearLCDLine(0);
  clearLCDLine(1);
  bLCDBacklight=true;
}

void LCDdisplay(string disp, int line)
{
  displayLCDCenteredString(line, disp);
}

void LCDdisplayn(short disp, int line)
{
  displayLCDNumber(line, 0, disp);
}

void turnRight(int degrees)
{
  motor[leftWheel]=127;
  motor[rightWheel]=-127;
  wait1Msec(degreeSecFloor*degrees*1000);
  motor[leftWheel]=0;
  motor[rightWheel]=0;
}

void turnLeft(int degrees)
{
  motor[leftWheel]=-127;
  motor[rightWheel]=127;
  wait1Msec(degreeSecFloor*degrees*1000);
  motor[leftWheel]=0;
  motor[rightWheel]=0;
}

void clawOpen()
{
  motor[claw]=127;
  wait1Msec(400);
  motor[claw]=0;
}
void clawClose()
{
  motor[claw]=-127;
  wait1Msec(500);
  motor[claw]=0;
}

bool getLCDButton(int button)
{
  if(button==1)
    return (nLCDButtons==1);
  if(button==2)
    return (nLCDButtons==2);
  if(button==3)
    return (nLCDButtons==4);
  return false;
}

void navigateTo(float leftEnc, float rightEnc)
{
  nMotorEncoder[leftWheel]=0;
  nMotorEncoder[rightWheel]=0;
  int left=0;
  int right=0;
while(abs(leftEnc-nMotorEncoder[leftWheel])>10||abs(rightEnc-nMotorEncoder[rightWheel])>10)
{
  string str1=nMotorEncoder[leftWheel];
  string str2=nMotorEncoder[rightWheel];
  strcat(str1, " ");
  strcat(str1, str2);
  //displayLCDCenteredString(1, str1);
  if(leftEnc-nMotorEncoder[leftWheel]>10)
  {
    left=100;
}
else if(leftEnc-nMotorEncoder[leftWheel]<10)
{
  left=-100;
}
else
{
  left=0;
}
if(rightEnc-nMotorEncoder[rightWheel]>10)
  {
    right=100;
}
else if(rightEnc-nMotorEncoder[rightWheel]<10)
{
  right=-100;
}
else
{
  right=0;
}
motor[leftWheel]=left;
motor[rightWheel]=right;
}
motor[leftWheel]=0;
motor[rightWheel]=0;
}
task armTurnPos
{
  nMotorEncoder[rightArm]=0;
  nMotorEncoder[leftArm]=0;
  while(true)
  {
    if(nMotorEncoder[rightArm]<200)
{
  motor[rightArm]=60;
}
else if(nMotorEncoder[rightArm]>200)
{
  motor[rightArm]=-60;
}
else
{
  motor[rightArm]=0;
}
if(nMotorEncoder[leftArm]<200)
{
  motor[leftArm]=60;
}
else if(nMotorEncoder[leftArm]>200)
{
  motor[leftArm]=-60;
}
else
{
  motor[leftArm]=0;
}

}
}

void lineTrack(long leftEnc, long rightEnc)
{
  short left;
  short right;
  nMotorEncoder[leftWheel]=0;
  nMotorEncoder[rightWheel]=0;
  while(abs(leftEnc-nMotorEncoder[leftWheel])>5||abs(rightEnc-nMotorEncoder[rightWheel])>5)
  {
    if(SensorValue(lfM)<2700)
    {
      if(leftEnc-nMotorEncoder[leftWheel]>5)
  {
    left=80;
}
else if(leftEnc-nMotorEncoder[leftWheel]<5)
{
  left=-80;
}
else
{
  left=0;
}
if(rightEnc-nMotorEncoder[rightWheel]>5)
  {
    right=80;
}
else if(rightEnc-nMotorEncoder[rightWheel]<5)
{
  right=-80;
}
else
{
  right=0;
}
  }
  else if(SensorValue(lfL)<2700)
    {
      if(leftEnc-nMotorEncoder[leftWheel]>5)
  {
    left=60;
}
else if(leftEnc-nMotorEncoder[leftWheel]<5)
{
  left=-60;
}
else
{
  left=0;
}
if(rightEnc-nMotorEncoder[rightWheel]>5)
  {
    right=80;
}
else if(rightEnc-nMotorEncoder[rightWheel]<5)
{
  right=-80;
}
else
{
  right=0;
}
  }
  else if(SensorValue(lfR)<2700)
    {
      if(leftEnc-nMotorEncoder[leftWheel]>5)
  {
    left=80;
}
else if(leftEnc-nMotorEncoder[leftWheel]<5)
{
  left=-80;
}
else
{
  left=0;
}
if(rightEnc-nMotorEncoder[rightWheel]>5)
  {
    right=60;
}
else if(rightEnc-nMotorEncoder[rightWheel]<5)
{
  right=-60;
}
else
{
  right=0;
}
  }
  motor[leftWheel]=left;
  motor[rightWheel]=right;
}
motor[leftWheel]=0;
motor[rightWheel]=0;
}
